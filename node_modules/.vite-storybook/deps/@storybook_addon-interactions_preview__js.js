import {
  instrument
} from "./chunk-WM5NT6F3.js";
import {
  addons
} from "./chunk-OF5MN6P4.js";
import "./chunk-4AYDH6ME.js";
import {
  FORCE_REMOUNT,
  STORY_RENDER_PHASE_CHANGED
} from "./chunk-D2A6N3WL.js";
import "./chunk-BHVGMYQT.js";
import "./chunk-M5MZH6BM.js";
import "./chunk-2NHA6JMY.js";
import "./chunk-CDKBD4KP.js";
import "./chunk-GZALBK6F.js";
import "./chunk-EYRJ7QYH.js";
import "./chunk-753FLWY3.js";
import "./chunk-YEZN4A7V.js";
import "./chunk-UNKE7MHK.js";
import "./chunk-F7MQGFJO.js";
import "./chunk-A235CEK4.js";
import "./chunk-TA4GF4XZ.js";
import "./chunk-BOOB774A.js";
import "./chunk-3NDHXG4J.js";
import "./chunk-CCVSUUY7.js";
import "./chunk-RZOMAMMP.js";
import {
  require_es_regexp_exec
} from "./chunk-MYEMQ6IM.js";
import {
  require_es_array_iterator,
  require_es_string_iterator
} from "./chunk-UIWCWERW.js";
import "./chunk-AVFEU4U7.js";
import "./chunk-3OBU7M4F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// .yarn/cache/jest-mock-npm-27.5.1-22d1da854d-f5b5904bb1.zip/node_modules/jest-mock/build/index.js
var require_build = __commonJS({
  ".yarn/cache/jest-mock-npm-27.5.1-22d1da854d-f5b5904bb1.zip/node_modules/jest-mock/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.spyOn = exports.mocked = exports.fn = exports.ModuleMocker = void 0;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var MOCK_CONSTRUCTOR_NAME = "mockConstructor";
    var FUNCTION_NAME_RESERVED_PATTERN = /[\s!-\/:-@\[-`{-~]/;
    var FUNCTION_NAME_RESERVED_REPLACE = new RegExp(
      FUNCTION_NAME_RESERVED_PATTERN.source,
      "g"
    );
    var RESERVED_KEYWORDS = /* @__PURE__ */ new Set([
      "arguments",
      "await",
      "break",
      "case",
      "catch",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "enum",
      "eval",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "function",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "interface",
      "let",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "static",
      "super",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "var",
      "void",
      "while",
      "with",
      "yield"
    ]);
    function matchArity(fn3, length) {
      let mockConstructor;
      switch (length) {
        case 1:
          mockConstructor = function(_a) {
            return fn3.apply(this, arguments);
          };
          break;
        case 2:
          mockConstructor = function(_a, _b) {
            return fn3.apply(this, arguments);
          };
          break;
        case 3:
          mockConstructor = function(_a, _b, _c) {
            return fn3.apply(this, arguments);
          };
          break;
        case 4:
          mockConstructor = function(_a, _b, _c, _d) {
            return fn3.apply(this, arguments);
          };
          break;
        case 5:
          mockConstructor = function(_a, _b, _c, _d, _e) {
            return fn3.apply(this, arguments);
          };
          break;
        case 6:
          mockConstructor = function(_a, _b, _c, _d, _e, _f) {
            return fn3.apply(this, arguments);
          };
          break;
        case 7:
          mockConstructor = function(_a, _b, _c, _d, _e, _f, _g) {
            return fn3.apply(this, arguments);
          };
          break;
        case 8:
          mockConstructor = function(_a, _b, _c, _d, _e, _f, _g, _h) {
            return fn3.apply(this, arguments);
          };
          break;
        case 9:
          mockConstructor = function(_a, _b, _c, _d, _e, _f, _g, _h, _i) {
            return fn3.apply(this, arguments);
          };
          break;
        default:
          mockConstructor = function() {
            return fn3.apply(this, arguments);
          };
          break;
      }
      return mockConstructor;
    }
    function getObjectType(value) {
      return Object.prototype.toString.apply(value).slice(8, -1);
    }
    function getType(ref) {
      const typeName = getObjectType(ref);
      if (typeName === "Function" || typeName === "AsyncFunction" || typeName === "GeneratorFunction") {
        return "function";
      } else if (Array.isArray(ref)) {
        return "array";
      } else if (typeName === "Object") {
        return "object";
      } else if (typeName === "Number" || typeName === "String" || typeName === "Boolean" || typeName === "Symbol") {
        return "constant";
      } else if (typeName === "Map" || typeName === "WeakMap" || typeName === "Set") {
        return "collection";
      } else if (typeName === "RegExp") {
        return "regexp";
      } else if (ref === void 0) {
        return "undefined";
      } else if (ref === null) {
        return "null";
      } else {
        return null;
      }
    }
    function isReadonlyProp(object, prop) {
      if (prop === "arguments" || prop === "caller" || prop === "callee" || prop === "name" || prop === "length") {
        const typeName = getObjectType(object);
        return typeName === "Function" || typeName === "AsyncFunction" || typeName === "GeneratorFunction";
      }
      if (prop === "source" || prop === "global" || prop === "ignoreCase" || prop === "multiline") {
        return getObjectType(object) === "RegExp";
      }
      return false;
    }
    var ModuleMocker2 = class {
      constructor(global2) {
        _defineProperty(this, "_environmentGlobal", void 0);
        _defineProperty(this, "_mockState", void 0);
        _defineProperty(this, "_mockConfigRegistry", void 0);
        _defineProperty(this, "_spyState", void 0);
        _defineProperty(this, "_invocationCallCounter", void 0);
        this._environmentGlobal = global2;
        this._mockState = /* @__PURE__ */ new WeakMap();
        this._mockConfigRegistry = /* @__PURE__ */ new WeakMap();
        this._spyState = /* @__PURE__ */ new Set();
        this._invocationCallCounter = 1;
      }
      _getSlots(object) {
        if (!object) {
          return [];
        }
        const slots = /* @__PURE__ */ new Set();
        const EnvObjectProto = this._environmentGlobal.Object.prototype;
        const EnvFunctionProto = this._environmentGlobal.Function.prototype;
        const EnvRegExpProto = this._environmentGlobal.RegExp.prototype;
        const ObjectProto = Object.prototype;
        const FunctionProto = Function.prototype;
        const RegExpProto = RegExp.prototype;
        while (object != null && object !== EnvObjectProto && object !== EnvFunctionProto && object !== EnvRegExpProto && object !== ObjectProto && object !== FunctionProto && object !== RegExpProto) {
          const ownNames = Object.getOwnPropertyNames(object);
          for (let i = 0; i < ownNames.length; i++) {
            const prop = ownNames[i];
            if (!isReadonlyProp(object, prop)) {
              const propDesc = Object.getOwnPropertyDescriptor(object, prop);
              if (propDesc !== void 0 && !propDesc.get || object.__esModule) {
                slots.add(prop);
              }
            }
          }
          object = Object.getPrototypeOf(object);
        }
        return Array.from(slots);
      }
      _ensureMockConfig(f) {
        let config = this._mockConfigRegistry.get(f);
        if (!config) {
          config = this._defaultMockConfig();
          this._mockConfigRegistry.set(f, config);
        }
        return config;
      }
      _ensureMockState(f) {
        let state = this._mockState.get(f);
        if (!state) {
          state = this._defaultMockState();
          this._mockState.set(f, state);
        }
        if (state.calls.length > 0) {
          state.lastCall = state.calls[state.calls.length - 1];
        }
        return state;
      }
      _defaultMockConfig() {
        return {
          mockImpl: void 0,
          mockName: "jest.fn()",
          specificMockImpls: [],
          specificReturnValues: []
        };
      }
      _defaultMockState() {
        return {
          calls: [],
          instances: [],
          invocationCallOrder: [],
          results: []
        };
      }
      _makeComponent(metadata, restore) {
        if (metadata.type === "object") {
          return new this._environmentGlobal.Object();
        } else if (metadata.type === "array") {
          return new this._environmentGlobal.Array();
        } else if (metadata.type === "regexp") {
          return new this._environmentGlobal.RegExp("");
        } else if (metadata.type === "constant" || metadata.type === "collection" || metadata.type === "null" || metadata.type === "undefined") {
          return metadata.value;
        } else if (metadata.type === "function") {
          const prototype = metadata.members && metadata.members.prototype && metadata.members.prototype.members || {};
          const prototypeSlots = this._getSlots(prototype);
          const mocker = this;
          const mockConstructor = matchArity(function(...args) {
            const mockState = mocker._ensureMockState(f);
            const mockConfig = mocker._ensureMockConfig(f);
            mockState.instances.push(this);
            mockState.calls.push(args);
            const mockResult = {
              type: "incomplete",
              value: void 0
            };
            mockState.results.push(mockResult);
            mockState.invocationCallOrder.push(mocker._invocationCallCounter++);
            let finalReturnValue;
            let thrownError;
            let callDidThrowError = false;
            try {
              finalReturnValue = (() => {
                if (this instanceof f) {
                  prototypeSlots.forEach((slot) => {
                    if (prototype[slot].type === "function") {
                      const protoImpl = this[slot];
                      this[slot] = mocker.generateFromMetadata(prototype[slot]);
                      this[slot]._protoImpl = protoImpl;
                    }
                  });
                  const mockImpl = mockConfig.specificMockImpls.length ? mockConfig.specificMockImpls.shift() : mockConfig.mockImpl;
                  return mockImpl && mockImpl.apply(this, arguments);
                }
                let specificMockImpl = mockConfig.specificMockImpls.shift();
                if (specificMockImpl === void 0) {
                  specificMockImpl = mockConfig.mockImpl;
                }
                if (specificMockImpl) {
                  return specificMockImpl.apply(this, arguments);
                }
                if (f._protoImpl) {
                  return f._protoImpl.apply(this, arguments);
                }
                return void 0;
              })();
            } catch (error) {
              thrownError = error;
              callDidThrowError = true;
              throw error;
            } finally {
              mockResult.type = callDidThrowError ? "throw" : "return";
              mockResult.value = callDidThrowError ? thrownError : finalReturnValue;
            }
            return finalReturnValue;
          }, metadata.length || 0);
          const f = this._createMockFunction(metadata, mockConstructor);
          f._isMockFunction = true;
          f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl;
          if (typeof restore === "function") {
            this._spyState.add(restore);
          }
          this._mockState.set(f, this._defaultMockState());
          this._mockConfigRegistry.set(f, this._defaultMockConfig());
          Object.defineProperty(f, "mock", {
            configurable: false,
            enumerable: true,
            get: () => this._ensureMockState(f),
            set: (val) => this._mockState.set(f, val)
          });
          f.mockClear = () => {
            this._mockState.delete(f);
            return f;
          };
          f.mockReset = () => {
            f.mockClear();
            this._mockConfigRegistry.delete(f);
            return f;
          };
          f.mockRestore = () => {
            f.mockReset();
            return restore ? restore() : void 0;
          };
          f.mockReturnValueOnce = (value) => f.mockImplementationOnce(() => value);
          f.mockResolvedValueOnce = (value) => f.mockImplementationOnce(() => Promise.resolve(value));
          f.mockRejectedValueOnce = (value) => f.mockImplementationOnce(() => Promise.reject(value));
          f.mockReturnValue = (value) => f.mockImplementation(() => value);
          f.mockResolvedValue = (value) => f.mockImplementation(() => Promise.resolve(value));
          f.mockRejectedValue = (value) => f.mockImplementation(() => Promise.reject(value));
          f.mockImplementationOnce = (fn3) => {
            const mockConfig = this._ensureMockConfig(f);
            mockConfig.specificMockImpls.push(fn3);
            return f;
          };
          f.mockImplementation = (fn3) => {
            const mockConfig = this._ensureMockConfig(f);
            mockConfig.mockImpl = fn3;
            return f;
          };
          f.mockReturnThis = () => f.mockImplementation(function() {
            return this;
          });
          f.mockName = (name) => {
            if (name) {
              const mockConfig = this._ensureMockConfig(f);
              mockConfig.mockName = name;
            }
            return f;
          };
          f.getMockName = () => {
            const mockConfig = this._ensureMockConfig(f);
            return mockConfig.mockName || "jest.fn()";
          };
          if (metadata.mockImpl) {
            f.mockImplementation(metadata.mockImpl);
          }
          return f;
        } else {
          const unknownType = metadata.type || "undefined type";
          throw new Error("Unrecognized type " + unknownType);
        }
      }
      _createMockFunction(metadata, mockConstructor) {
        let name = metadata.name;
        if (!name) {
          return mockConstructor;
        }
        const boundFunctionPrefix = "bound ";
        let bindCall = "";
        if (name && name.startsWith(boundFunctionPrefix)) {
          do {
            name = name.substring(boundFunctionPrefix.length);
            bindCall = ".bind(null)";
          } while (name && name.startsWith(boundFunctionPrefix));
        }
        if (name === MOCK_CONSTRUCTOR_NAME) {
          return mockConstructor;
        }
        if (RESERVED_KEYWORDS.has(name) || /^\d/.test(name)) {
          name = "$" + name;
        }
        if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {
          name = name.replace(FUNCTION_NAME_RESERVED_REPLACE, "$");
        }
        const body = "return function " + name + "() {return " + MOCK_CONSTRUCTOR_NAME + ".apply(this,arguments);}" + bindCall;
        const createConstructor = new this._environmentGlobal.Function(
          MOCK_CONSTRUCTOR_NAME,
          body
        );
        return createConstructor(mockConstructor);
      }
      _generateMock(metadata, callbacks, refs) {
        const mock = this._makeComponent(metadata);
        if (metadata.refID != null) {
          refs[metadata.refID] = mock;
        }
        this._getSlots(metadata.members).forEach((slot) => {
          const slotMetadata = metadata.members && metadata.members[slot] || {};
          if (slotMetadata.ref != null) {
            callbacks.push(
              function(ref) {
                return () => mock[slot] = refs[ref];
              }(slotMetadata.ref)
            );
          } else {
            mock[slot] = this._generateMock(slotMetadata, callbacks, refs);
          }
        });
        if (metadata.type !== "undefined" && metadata.type !== "null" && mock.prototype && typeof mock.prototype === "object") {
          mock.prototype.constructor = mock;
        }
        return mock;
      }
      generateFromMetadata(_metadata) {
        const callbacks = [];
        const refs = {};
        const mock = this._generateMock(_metadata, callbacks, refs);
        callbacks.forEach((setter) => setter());
        return mock;
      }
      getMetadata(component, _refs) {
        const refs = _refs || /* @__PURE__ */ new Map();
        const ref = refs.get(component);
        if (ref != null) {
          return {
            ref
          };
        }
        const type = getType(component);
        if (!type) {
          return null;
        }
        const metadata = {
          type
        };
        if (type === "constant" || type === "collection" || type === "undefined" || type === "null") {
          metadata.value = component;
          return metadata;
        } else if (type === "function") {
          metadata.name = component.name;
          if (component._isMockFunction === true) {
            metadata.mockImpl = component.getMockImplementation();
          }
        }
        metadata.refID = refs.size;
        refs.set(component, metadata.refID);
        let members = null;
        if (type !== "array") {
          this._getSlots(component).forEach((slot) => {
            if (type === "function" && component._isMockFunction === true && slot.match(/^mock/)) {
              return;
            }
            const slotMetadata = this.getMetadata(component[slot], refs);
            if (slotMetadata) {
              if (!members) {
                members = {};
              }
              members[slot] = slotMetadata;
            }
          });
        }
        if (members) {
          metadata.members = members;
        }
        return metadata;
      }
      isMockFunction(fn3) {
        return !!fn3 && fn3._isMockFunction === true;
      }
      fn(implementation) {
        const length = implementation ? implementation.length : 0;
        const fn3 = this._makeComponent({
          length,
          type: "function"
        });
        if (implementation) {
          fn3.mockImplementation(implementation);
        }
        return fn3;
      }
      spyOn(object, methodName, accessType) {
        if (accessType) {
          return this._spyOnProperty(object, methodName, accessType);
        }
        if (typeof object !== "object" && typeof object !== "function") {
          throw new Error(
            "Cannot spyOn on a primitive value; " + this._typeOf(object) + " given"
          );
        }
        const original = object[methodName];
        if (!this.isMockFunction(original)) {
          if (typeof original !== "function") {
            throw new Error(
              "Cannot spy the " + methodName + " property because it is not a function; " + this._typeOf(original) + " given instead"
            );
          }
          const isMethodOwner = Object.prototype.hasOwnProperty.call(
            object,
            methodName
          );
          let descriptor = Object.getOwnPropertyDescriptor(object, methodName);
          let proto = Object.getPrototypeOf(object);
          while (!descriptor && proto !== null) {
            descriptor = Object.getOwnPropertyDescriptor(proto, methodName);
            proto = Object.getPrototypeOf(proto);
          }
          let mock;
          if (descriptor && descriptor.get) {
            const originalGet = descriptor.get;
            mock = this._makeComponent(
              {
                type: "function"
              },
              () => {
                descriptor.get = originalGet;
                Object.defineProperty(object, methodName, descriptor);
              }
            );
            descriptor.get = () => mock;
            Object.defineProperty(object, methodName, descriptor);
          } else {
            mock = this._makeComponent(
              {
                type: "function"
              },
              () => {
                if (isMethodOwner) {
                  object[methodName] = original;
                } else {
                  delete object[methodName];
                }
              }
            );
            object[methodName] = mock;
          }
          mock.mockImplementation(function() {
            return original.apply(this, arguments);
          });
        }
        return object[methodName];
      }
      _spyOnProperty(obj, propertyName, accessType = "get") {
        if (typeof obj !== "object" && typeof obj !== "function") {
          throw new Error(
            "Cannot spyOn on a primitive value; " + this._typeOf(obj) + " given"
          );
        }
        if (!obj) {
          throw new Error(
            "spyOn could not find an object to spy upon for " + propertyName
          );
        }
        if (!propertyName) {
          throw new Error("No property name supplied");
        }
        let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
        let proto = Object.getPrototypeOf(obj);
        while (!descriptor && proto !== null) {
          descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);
          proto = Object.getPrototypeOf(proto);
        }
        if (!descriptor) {
          throw new Error(propertyName + " property does not exist");
        }
        if (!descriptor.configurable) {
          throw new Error(propertyName + " is not declared configurable");
        }
        if (!descriptor[accessType]) {
          throw new Error(
            "Property " + propertyName + " does not have access type " + accessType
          );
        }
        const original = descriptor[accessType];
        if (!this.isMockFunction(original)) {
          if (typeof original !== "function") {
            throw new Error(
              "Cannot spy the " + propertyName + " property because it is not a function; " + this._typeOf(original) + " given instead"
            );
          }
          descriptor[accessType] = this._makeComponent(
            {
              type: "function"
            },
            () => {
              descriptor[accessType] = original;
              Object.defineProperty(obj, propertyName, descriptor);
            }
          );
          descriptor[accessType].mockImplementation(function() {
            return original.apply(this, arguments);
          });
        }
        Object.defineProperty(obj, propertyName, descriptor);
        return descriptor[accessType];
      }
      clearAllMocks() {
        this._mockState = /* @__PURE__ */ new WeakMap();
      }
      resetAllMocks() {
        this._mockConfigRegistry = /* @__PURE__ */ new WeakMap();
        this._mockState = /* @__PURE__ */ new WeakMap();
      }
      restoreAllMocks() {
        this._spyState.forEach((restore) => restore());
        this._spyState = /* @__PURE__ */ new Set();
      }
      _typeOf(value) {
        return value == null ? "" + value : typeof value;
      }
      mocked(item, _deep = false) {
        return item;
      }
    };
    exports.ModuleMocker = ModuleMocker2;
    var JestMock2 = new ModuleMocker2(global);
    var fn2 = JestMock2.fn.bind(JestMock2);
    exports.fn = fn2;
    var spyOn = JestMock2.spyOn.bind(JestMock2);
    exports.spyOn = spyOn;
    var mocked = JestMock2.mocked.bind(JestMock2);
    exports.mocked = mocked;
  }
});

// .yarn/__virtual__/@storybook-addon-interactions-virtual-a8844bc103/0/cache/@storybook-addon-interactions-npm-6.5.13-ddf1fe3273-5c940dc55b.zip/node_modules/@storybook/addon-interactions/dist/esm/preset/preview.js
var import_es_array_iterator = __toESM(require_es_array_iterator());
var import_es_string_iterator = __toESM(require_es_string_iterator());
var import_es_regexp_exec = __toESM(require_es_regexp_exec());
var import_jest_mock = __toESM(require_build());
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var JestMock = new import_jest_mock.ModuleMocker(global);
var fn = JestMock.fn.bind(JestMock);
var _instrument = instrument({
  action: fn
}, {
  retain: true
});
var action = _instrument.action;
var channel = addons.getChannel();
var spies = [];
channel.on(FORCE_REMOUNT, function() {
  return spies.forEach(function(mock) {
    var _mock$mockClear;
    return mock === null || mock === void 0 ? void 0 : (_mock$mockClear = mock.mockClear) === null || _mock$mockClear === void 0 ? void 0 : _mock$mockClear.call(mock);
  });
});
channel.on(STORY_RENDER_PHASE_CHANGED, function(_ref) {
  var newPhase = _ref.newPhase;
  if (newPhase === "loading")
    spies.forEach(function(mock) {
      var _mock$mockClear2;
      return mock === null || mock === void 0 ? void 0 : (_mock$mockClear2 = mock.mockClear) === null || _mock$mockClear2 === void 0 ? void 0 : _mock$mockClear2.call(mock);
    });
});
var addActionsFromArgTypes = function addActionsFromArgTypes2(_ref2) {
  var id = _ref2.id, initialArgs = _ref2.initialArgs;
  return Object.entries(initialArgs).reduce(function(acc, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    if (typeof val === "function" && val.name === "actionHandler") {
      Object.defineProperty(val, "name", {
        value: key,
        writable: false
      });
      Object.defineProperty(val, "__storyId__", {
        value: id,
        writable: false
      });
      acc[key] = action(val);
      spies.push(acc[key]);
      return acc;
    }
    acc[key] = val;
    return acc;
  }, {});
};
var argsEnhancers = [addActionsFromArgTypes];
export {
  argsEnhancers
};
//# sourceMappingURL=@storybook_addon-interactions_preview__js.js.map
